---
title: Шаблоны утилит Calculate
hide_title: true
---

## Введение

Традиционно в ОС Linux настройки приложений хранятся в текстовых файлах,
как правило в директории `/etc`, реже в `/var`. Форматы таких
конфигурационных файлов различаются: от простых "переменная=значение",
до более сложных C-подобных конструкций, либо составленных в XML.

Простой на первый взгляд подход обеспечивает исключительную стабильность
в работе приложений, так как за сохранность настроек отвечает
исключительно файловая система.

Различные дистрибутивы Linux, как правило, предлагают свои программы
настройки приложений. К сожалению, такой подход, имея неоспоримое
преимущество в удобстве, имеет также ряд недостатков:

-   пользователь привязывается к определенной программе настройки
    (дистрибутиву);
-   количество настроек, как правило, ограничено интерфейсом программы;
-   прямое редактирование настроек становится затруднительным, т.к.
    программа переписывает файл при внесении изменений.

### Особенности работы с шаблонами

В утилитах Calculate 2 и 3 подход к шаблонам был существенно переработан
и обладает рядом отличий от первой версии:

-   Основной метод переноса шаблонов - объединение с конфигурационными
    файлами системы. При этом поддерживаются все популярные форматы
    файлов.
-   Объединение шаблона с конфигурационным файлом производится
    посредством конвертации в XML формат. При этом формат файла шаблона
    может отличаться от конфигурационного файла.
-   Файл шаблона может содержать заголовок, описывающий методы
    объединения.
-   Имена встроенных переменных переименованы согласно типу.

## Шаблоны установки

Программа Calculate заменяет прямое редактирование файлов настроек на
создание шаблонов.

### Форматы файлов

Согласно методу хранения данных, файлы шаблонов могут иметь один из
перечисленных форматов:

-   **apache, kde, bind, postfix, proftpd, samba, procmail, ldap,
    dovecot, xml_xfce, xml_xfcepanel, xml_gconf, xml_gconf_tree, compiz,
    plasma, squid, dhcp, openrc, kernel, json, world** - форматы файлов
    настроек распространенных приложений
-   **bin** - двоичный формат файлов
-   **raw** - сырой текст
-   **patch** - шаблон для применения регулярных выражений (использует
    специальный вид объединения *patch*).
-   **diff** - шаблон для наложения патчей, полученных командой diff
-   **dconf** - файл модификации настроек в пользовательской службе
    dconf
-   **ldif** - формат представления записей службы каталогов или их
    изменений в текстовой форме
-   **contents** - специализированный формат для изменения
    принадлежности файлов пакетам
-   **backgrounds** - специализированный формат для создания фоновых
    изображений

Для формата kde не обрабатываются параметры '-','+' для элементов
внутри области.

Названия параметров в openrc-формате нечувствительны к регистру букв.

Формат ldif доступен только при наличии ldap модуля Calculate утилит.

Формат dconf доступен в шаблонах настройки пользовательского профиля,
при наличии пакета `gnome-base/dconf`.

### Управляющие элементы

Помимо настроек сервисов, записанных в оригинальном формате программы,
файлы шаблонов содержат служебные записи, которые условно можно
разделить на несколько типов.

#### Переменная

Переменная - текстовый элемент в шаблоне, имеющий имя, который
заменяется в соответствующем конфигурационном файле значением.

Переменная имеет имя, значение, область действия.

-   имя - латинские буквы и цифры
-   значение - текст для замены (создается в программе)
-   область действия - действует глобально для всех шаблонов или
    локально для одного

Переменные подразделяются на переменные шаблонов и переменные функций.

У переменных шаблонов глобальная область действия, то есть любая
переменная шаблона, доступная программе, может быть использована в любом
шаблоне. Значение переменной нельзя изменить в шаблоне.

Переменные функций могут быть созданы в шаблоне; также можно изменить
значение переменной в шаблоне. Область действия переменной функции -
текущий шаблон.

Для передачи значений переменных функций из текущего шаблона в другой
шаблон используется стек переменных функций шаблонов (LIFO), в который
при помощи функции шаблонов `push()` записывается значение из текущего
шаблона, а функцией шаблона `pop()` получаем значение в другом шаблоне.

#### Стек переменных функций шаблонов

Стек (LIFO - "последним пришел, первым вышел") для хранения значений
переменных функций. Доступен глобально для всех шаблонов, для работы
используются функции шаблонов, `push()` - запись, `pop()` - чтение.
Запись и чтение возможны как в одном шаблоне, так и в разных.

#### Заголовок

Заголовок - управляющая запись шаблона, определяющая методы переноса
шаблона в систему. Заголовок шаблона записывается первой строкой файла и
имеет следующий вид:

   ` # Calculate параметр1=значение1 параметр2 [параметр3=значение3 ...]`

Содержимое заголовка может быть разбито на строки. В этом случае в конце
каждой строки заголовка, кроме последней, должен стоять знак ""
(обратная косая черта).

Если заголовок отсутствует, настройки файла шаблона определяются исходя
из принятых значений по умолчанию.

**Допустимые параметры:**
*Формат*

-   **format=[...]** - формат файла шаблона (см. форматы файлов). По
    умолчанию формат файла шаблона определяется как "raw", или "bin"
    для файлов, содержащих двоичные данные.
-   **comment=[.]** - обозначение начала строкового комментария
    (пример: "#").

*Объединение*

-   **append=[join|before|after|replace|remove|skip|patch|clear]** -
    способ объединения. По умолчанию способ объединения устанавливается
    в соответствии с форматом файла. Если append=skip - шаблон
    пропускается. Если append=clear, в случае шаблона файла
    конфигурационный файл будет очищен - длина файла 0, а в случае
    шаблона директории все файлы и директории внутри конфигурационной
    директории будут удалены.
-   **force** - удалять существующие файлы перед записью
    конфигурационного файла. Правило действует по умолчанию, если указан
    параметр "symbolic".
-   **link=путь** - путь к конфигурационному файлу, с которым
    объединяется файл шаблона. По умолчанию путь совпадает. В версии
    **3.5** добавлена поддержка параметра для шаблона директории: в
    созданный каталог будут скопированы все файлы, символические ссылки,
    и директории из указанной по `link` директории. `link` для
    директории поддерживает только два типа `append`: `join` и
    `replace`. При использовании `replace` файлы из целевой директории
    будут удалены перед копированием.
    Пример: "link=/etc/conf.d/net.example"
-   **path=путь** - путь к директории, в которой будет находиться
    конфигурационный файл
-   **name=имя** - имя конфигурационного файла
-   **mirror** - выполнять объединение только в случае существования
    конфигурационного файла. Если конфигурационный файл задан параметром
    "link" и он не существует, файл назначения удаляется.
-   **proteсted** **(добавлено в 3.1.1)** - защитить файл при удалении
    пакета, которому он принадлежит.
-   **symbolic** - создать символическую ссылку на файл, указанный
    параметром "link".
-   **autoupdate** - при установке любого пакета запускается специальный
    скрипт `cl-update-config`, который применяет шаблоны для
    устанавливаемого пакета. Конфигурационные файлы устанавливаемого
    пакета защищены. Иными словами, при установке пакета, если такой же
    файл существует в системе и изменен, он не будет заменен. Замена
    конфигурационных файлов установленных пакетов производится командой
    **dispatch-conf**. Если в заголовке шаблона есть параметр
    **autoupdate** то после применения шаблона конфигурационный файл
    будет скопирован в систему. Если параметр отсутствует то для
    переноса измененного конфигурационного файла необходимо использовать
    **dispatch-conf**.
-   **run** **(добавлено в 3.1.1)** - оболочка для выполнения
    конфигурационного файла, полученного из шаблона. Сценарий
    выполняется сразу же после обработки этого шаблона.
    Пример: "run=/bin/bash"
-   **exec** - оболочка для выполнения конфигурационного файла,
    полученного из шаблона. Сценарий добавляется в очередь, которая
    выполняется после обработки всех неисполняемых шаблонов.
    Пример: "exec=/bin/bash" (начиная с версии 3.1.1 выполняемый
    сценарий не сохраняется на диск)
-   **env** - **(добавлено в 3.1)** использовать в шаблоне переменные
    указанного модуля. Если модуль в системе отсутствует - шаблон будет
    пропущен.
    Пример: "env=install"

*Действия*

-   **merge** - выполнить в конце настройку перечисленных пакетов.
    Пример: "merge=openrc,grub" (начиная с версии 3.1.1 пакеты
    необходимо указывать вместе с категорией
    `merge=sys-apps/openrc,sys-boot/grub`)
-   **postmerge** (добавлено в 3.1.10) - выполнить в конце настройку
    перечисленных пакетов. В отличие от merge пакеты будут настроены
    после `pkg_postinst()` во время сборки пакета.
    Пример: "postmerge=sys-apps/openrc,sys-boot/grub"
-   **stop**, **start**, **restart** - **(добавлено в 3.5)** выполнить
    остановку/запуск/перезапуск указанных через запятую сервисов. Для
    шаблона файла действие с сервисом будет выполнено сразу после
    выполнения шаблона, для шаблона директории действие с сервисом будет
    выполнено сразу после обработки всех вложенных шаблонов.
    Пример: restart=consolefont,keymap
-   **rebuild** - **(добавлено в 3.5)** понизить версию пакета, для
    последующей его пересборки во время обновления системы.
    Поддерживается указание слотов и версий пакетов.

*Права доступа*

-   **chmod=XXX** - права доступа к конечному файлу (пример: "644").
    По умолчанию права соответствуют оригинальному файлу. Если его нет,
    права соответствуют файлу шаблона.
-   **chown=user:group** - владелец и/или группа конечного файла
    (пример: "root:root").

*Условия*

-   **переменная[\>|\<|==|!=|\>=|\<=]значение ...** - условия
    переноса файла шаблона в систему. Арифметические операции могут
    объединяться условием "И" (&) (для версии calculate-lib\>=2.2
    условие "И" (&&)) и "ИЛИ" (||). Приоритет в данном случае
    будет отдаваться условию И. Несколько условий, разделённых пробелом
    будут объединяться условием "И", если одно из условий не будет
    выполнено - остальные вычисляться не будут. Таким образом
    `cl_ver\>=3.5 os_linux_shortname==CLDX||os_linux_shortname==CLD`
    обрабатывается как
    `cl_ver\>=3.5 И (os_linux_shortname==CLDX ИЛИ os_linux_shortname==CLD)`.

#### Метки

Вы можете настроить систему исходя из *аппаратных требований*
компьютера, *сетевых установок* и прочих условий. Для этого в файле
шаблона вы можете вместо постоянных значений устанавливать *метки*
переменных.

Пример файла `/etc/conf.d/hostname`:

    HOSTNAME="#-os_net_hostname-#" 

Для использования переменных из другого модуля перед переменной, через
точку указывается модуль **(добавлено в 3.1)**:

Пример:

    #-install.os_install_root_dev-#

#### Условные блоки

Файл шаблона может содержать *условные блоки*.

Условные блоки - выделенный текст шаблона, подставляемый в случае
соответствия *регулярного выражения*.

*Регулярное выражение* - метод проверки значений выражений. В качестве
значений могут применяться следующие *типы данных*:

-   **переменные** - встроенные переменные Calculate.
-   **числа** - целые и дробные числа, в качестве разделителя дробной
    части выступает точка ".".
-   **строки** - буквы, цифры, специальные символы.
-   **номера версий** - числа и одна или две точки, разделяющих номер
    версии (например, 8.5.1).
-   **интервалы версий** - два номера версий, разделённые запятой
    **(добавлено в версии 3.5)**

Методом проверки выступает арифметическая операция **\>, \<, ==, !=,
\>=, \<=** (больше, меньше, равно, не равно, больше либо равно, меньше
либо равно). Тип данных определяется перед операцией сравнения.

Начиная с версии 3.5 добавлена возможность проверять вхождение версии в
интервал. Для проверки используются следующие операторы:

-   **==** - версия `>=` меньшего значению и версия `<=` большего
    значению
-   **\<=** - версия `>` меньшего значению и версия `<=` большего
    значению
-   **=\>** - версия `>=` меньшего значению и версия `<` большего
    значению
-   **\<\>** - версия `>` меньшего значению и версия `<` большего
    значению
-   **!=** - версия не входит в указанный интервал

Пример:

    версия утилит больше или равна 3.3 и меньше 4
    #?pkg(sys-apps/calculate-utils)=\>3.3,4#

Арифметические операции могут объединяться условием "И" (&) и "ИЛИ"
(||). Приоритет в данном случае будет отдаваться условию "И".

Условный блок должен начинаться с метки
"#?переменная1==значение1(...)#" и заканчивается "#переменная1#",
записанными в начале строки.

Пример условного блока файла `/etc/make.conf`:

    #?os_arch_march==i686&&os_linux_shortname==CLD#
       CFLAGS="-O2 -march=i686 -pipe" 
       CHOST="i686-pc-linux-gnu" 
    #os_arch_march#

В приведенном примере сравниваются переменные `setup_march` и
`setup_sys_shortname` со строковыми значениями "i686" и "CLD"
соответственно. В случае, если значения обоих переменных совпадают,
текст блока будет подставлен в результирующий файл.

#### Функции

Для формирования сложных файлов, требующих вычисления во время
обработки, служат функции. Подобно переменным, функции вставляются в
текст шаблона при помощи конструкции `"#-функция()-#"`.

Функции, использующие в аргументах путь к файлу (**path**), могут
использовать в качестве домашней директории пользователя '~'

Доступные функции:

**belong - (не используется начиная с 3.1.1)** - назначение такое же как
у merge, за исключением, что она работает только с именем пакета, не
учитывая категорию.

**merge([category/pkg_name])** - проверка имени устанавливаемого
пакета, если выполняется установка пакета. В остальных случаях функция
будет возвращать положительный результат.

category - категория пакета.
pkg_name - имя пакета.

Если у функции нет аргумента, то именем пакета становится имя шаблона
(для директорий - имя директории), категорией - родительская директория.
При чем если в имени категории или имени пакета есть версия и/или число
для сортировки (20-mc,40-xfce-4.6), то они отбрасываются.

Примеры:
**`sys-apps/15-portage-2.2/.calculate_directory`,
category=sys-apps,pkg_name=portage
**`sys-fs/udev`, (portage файл), category=sys-fs,pkg_name=udev

Результат зависит от значения переменной шаблона cl_merge_pkg (в версиях
ниже 3.1.1 cl_belong_pkg)

-   значение cl_merge_pkg - ''
    -   результат '1', независимо от того, есть или нет аргумент у
        функции
-   значение cl_merge_pkg - 'имя_пакета'
    -   если совпадают значения cl_merge_pkg и аргумента функции,
        результат - '1' иначе ''
    -   если у функции нет аргумента то сравниваются значение
        cl_merge_pkg и имя директории в которой находится шаблон с
        функцией merge(), в случае совпадения результат - '1' иначе
        ''

При выполнении шаблонов для модификации исходного кода пакетов
(`ac_install_patch`) функция в случае положительного результата
возвращает номер версии вместо 1.

Пример.
Заголовок шаблона1:

    `# Calculate merge(sys-auth/nss_ldap)!=`

Заголовок шаблона2:

   ` # Calculate merge(kde-libs/kdm)!=`

1.  Наложим шаблон для программы sys-auth/nss_ldap: Установим значение
    переменной cl_merge_pkg равным sys-auth/nss_ldap. Будет применен
    только шаблон1
2.  Наложим все шаблоны. Значение переменной cl_merge_pkg по умолчанию -
    ''. Будут применены шаблон1 и шаблон2.

Если параметром для merge указан (или определен по пути шаблона) не
существующий пакет, то функция возвращает пустое значение.

**mergepkg(category/package)** - **добавлена в 3.5**, объединённый вызов
merge и pkg. Возвращает версию установленного (или устанавливаемого)
пакета в системе, если выполняется настройки именно этого пакета или
перенастраивается вся система.

**case(type,var)** - вывод значения переменной шаблона с изменением
регистра символов.
где:

-   *type* - тип изменения регистра: upper - верхний регистр, lower -
    нижний регистр, capitalize - первая буква в верхнем регистре.
-   *var* - название переменной шаблона.

Пример. Выведем название хоста в верхнем регистре:

    #-case(upper,os_net_hostname)-#

**cut(number,delimiter,data)** - **добавлено в 3.5**, разделяет строку
на подстроки и возвращает указанную.

где:

-   *number* - номер возвращаемой подстроки (от 0). Если функция
    вызывается без параметров, то номер равен 0.
-   *delimiter* - разделитель, если параметр указан, но пустой - то
    разделитель запятая. Если параметр не указан, то разделитель будут
    `-`.
-   *data* - строка, может быть результатом работы функции или значеним
    переменной. Если параметр не указан, то будет использоваться
    значение переменной `cl_pass_file` (имя файла шаблона).

Пример.

    #os_audio_default содержит номер звуковой карты и номер устройства через запятую, получим номер устройства
    #-cut(1,,#-os_audio_default-#)-#
    #Получить номер из имени шаблона (05-rebuild_openrc)
    #-cut()-#
    #Получить имя шаблона без цифры
    #-cut(1)-#

**disk(mount_point,name)** - выводит значение параметра жесткого диска
при инсталяции системы.
Значение функция получает из переменной ('os_install_disk_' + name,
если такой не существует, то 'os_disk_'+ name), для поиска нужного
значения используется переменная os_install_disk_mount (точки
монтирования при инсталяции).

где:

-   *mount_point* - точка монтирования при инсталяции.
-   *name* - последний элемент переменных начинающихся на
    os_install_disk_/os_disk ('os_instll_disk_'/'os_disk_' +
    name).

значения переменных

os_install_disk_mount = ['swap', '/', '', '',
'/var/calculate']
os_disk_grub ['0,0', '0,1', '0,2', '0,3', '0,4']

функция
disk(/var/calculate,grub)

-   в переменной os_install_disk_mount находим /var/calculate, получаем
    индекс 4
-   в переменной os_disk_grub по индексу 4 получаем значение '0,4'
    результат функции disk(/var/calculate,grub) '0,4'

функция
disk(/boot,grub)

-   в переменной os_install_disk_mount /boot не найден, индекс
    отсутствует
-   если индекс отсутствует, в переменной os_disk_install находим /,
    получаем индекс 1
-   в переменной os_disk_grub по индексу 1 получаем значение '0,1'
    результат функции disk(/boot,grub) '0,1'

Пример.
Выведем диск для загрузчика grub:

    #-disk(/boot,grub)-#

получаем значение 0,1

**elog(pkg)** - получить отметку времени (timestamp) установки
указанного пакета. Если пакет не указан, возвращается время последнего
установленного пакета. Информация извлекается из `emerge.log`. Функция
используется для определения необходимости настройки профиля
пользователя при входе его в сеанс.

где:
pkg - полное название пакета с категорией

**env(module.var_name)** - чтение значения переменной модуля из
calculate.env файлов.

где:

-   *module* - название модуля.
-   *var_name* - переменная сервиса.
    разделитель - '.' точка

Примеры:

1.  прочитаем из calculate.env файлов имя домена, в который введена
    машина

        #-env(client.os_remote_auth)-#

получаем значение например domain-server, если
`/etc/calculate/calculate.env` содержит

    [client]
    os_remote_auth = domain-server

**exists(path,opt)** - проверка существования файла или директории.

Если файл или директория существует, выводит '1', иначе ''. Начиная
с версии (**3.5**) вместо 1 возвращает обозначение типа файла:

-   `d` - директория
-   `f` - файл
-   `l` - символическая ссылка
-   `s` - сокет
-   `b` - буфферизованное блочное устройство
-   `c` - небуфферизованное блочное устройство
-   `p` - FIFO

path - путь в файловой системе.
opt - необязательная опция.

Возможные значения "opt":

-   *root* - путь к файлу не будет содержать chroot-пути. (Какой путь
    указан, такой будет в действительности - вне зависимости от
    переменных `cl_chroot_path` и `cl_root_path`)

Пример. Проверим существование директории `/etc`:

    #-exists(/etc)-#

Результатом будет `'1'` в утилитах до версии 3.5, и `'d'` в новых
утилитах.

**grep(file,regex)** - *(добавлена в 3.3.1) получить значение из файла
`file`, соответствующее регулярному выражению `regex`. Если в регулярном
выражении используется группировка значений, функция возвращает
содержимое первой группы.

Начиная с версии 3.3.1.2 преобразовывается xFF, где FF двузначный
шестнадцатеричный код символа.

Пример. Получить значение nofscks из dracut.conf.

    #-grep(/etc/dracut.conf,nofscks="(.*?)")-#

Специальные символы регулярного выражения (РВ):

  -  **"."** - соответствует любому символу, исключая новую строку. При включённом режиме **dotall** соответствует любому символу.
  -  **"^"** - соответствует началу файла.  При включённом режиме **multiline** соответствует началу строки.
  -  **"$"** - соответствует концу файла. При включённом режиме **multiline** соответствует концу строки. 
  -  **"*"** - соответствует 0 и более повторении предшествующего РВ. РВ будет соответствовать максимально возможной части текста.
  -  **"*?"** - "не жадная" версия использования предыдущего символа. РВ будет соответствовать минимально возможной части текста.
  -  **"+"** - соответствует 1 и более повторении предшествующего РВ. РВ будет соответствовать максимально возможной части текста.
  -  **"+?"** - "не жадная" версия использования предыдущего символа. РВ будет соответствовать минимально возможной части текста.
  -  **"?"** - соответствует 0 или 1 повторению предшествующего РВ. РВ будет соответствовать максимально возможной части текста.
  -  **"??"** - "не жадная" версия использования предыдущего символа. РВ будет соответствовать минимально возможной части текста.
  - **"\{m,n\}"** - соответствует от m до n повторений предшествуеющего РВ.
  - **"\{m,n\}?"** - "не жадная" версия использования предыдущей конструкции. РВ будет соответствовать минимально возможной части текста.
  - **""** - экранирвание спецсимволов
  - **"[]"** - соответствует любому символу из указанного набора.
  - **"[^]"** - соответствует любому символу не из указанного набора.
  - **"A|B"** - создать РВ соответствующее и А и В.
  - **"(...)"** - группировка РВ с сохранением групп (grep возвращает
  - содержимое первой группы)
  - **"(?ims)"** - устанавливает режимы РВ: регистронезависмый, multiline,dotall.
  - **"(?:...)"** - группировка РВ без сохранения групп
  - **"(?=...)"** - проверка текста после РВ на совпадение.
  - **"(?!...)"** - проверка текста после РВ на не совпадение.
  - **"(?\<=...)"** - проверка текста перед РВ на совпадение (это РВ должно быть фиксированной длины).
  - **"(?\<!...)"** - проверка текста перед РВ на не совпадение (это РВ должно быть фиксированной длины).
  - **"w"** - соответствует любому символу из набора [a-zA-Z0-9_]
  - **"W"** - соответствует любому символу не из набора [^a-zA-Z0-9_]
  - **"s"** - соответствует любому пробельному символу
  - **"S"** - соответствует любому не пробельному символу
  - **"d"** - соответствует любой десятичной цифре [0-9]
  - **"D"** - соответствует любому символу, не являющемуся десятичной цифрой [^0-9]

**groups(group1,group2,..groupN)** - проверка вхождения пользователя в
группы group1,group2, ..groupN
Если пользователь входит хотя бы в одну из групп выводит '1', иначе
''

group1 .. groupN - названия групп.

Пример. Проверим входит ли пользователь в группу *wheel*:

    #-groups(wheel)-#

Если пользователь входит в группу *wheel*, результатом будет '1'.

**ini(var, value, opt)** - запись и чтение переменной из
конфигурационного файла пользователя (`~/.calculate/ini.env`).

*Начиная с версии 2.2.20-r4: если функция выполняется для настройки
системы, то конфигурационный файл будет находиться в
`/etc/calculate/ini.env`.*

где:

-   *var* - имя переменной функции. Имя должно начинаться с буквы и
    может содержать латинские буквы и цифры, а также точку. Точка служит
    разделителем для раздела и имени переменной для размещения в
    конфигурационном файле.
-   *value* - значение переменной функции, значение присваивается
    переменной функции и записывается в конфигурационный файл (функция
    при этом возвращает пустое значение). При отсутствии второго
    аргумента переменная считывается из конфигурационного файла; при
    отсутствии названия переменной в конфигурационном файле в переменную
    записывается пустое значение.
    *Начиная с версии 2.2.20-r4, если аргумент пустая строка без
    кавычек, то переменная удаляется. Если аргумент - пустая строка в
    кавычках, то значение переменной в ini-файле очищается.*
-   *opt* - опция преобразования значения переменной, необязательный
    параметр; возможные значения url, purl, unicode, hexcode (добавлено
    в 3.6.1.9). При использовании этого аргумента второй аргумент
    функции должен быть пустым.

Примеры:
1. Создадим переменную "test" и присвоим ей значение 15, запишем в
конфигурационный файл:

    #-ini(test,15)-#

2. Считаем значение ранее записанной в конфигурационный файл переменной
test, заменим функцию значением считанной переменной, в нашем случае
"15":

    #-ini(test)-#

3. Использование функции ini c тремя аргументами. Предположим,что в
файле `~/.calculate/ini.env` существует секция

    [test]
    param = Тестовый параметр

тогда функция

    #-ini(test.param,,unicode)-#

вернет

    `\u0422\u0435\u0441\u0442\u043e\u0432\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440`

функция

    #-ini(test.param,,hexcode)-#

вернет

    `\x422\x435\x441\x442\x43e\x432\x44b\x439 \x43f\x430\x440\x430\x43c\x435\x442\x440`

функция

    #-ini(test.param,,url)-#

вернет

    `%d0%a2%d0%b5%d1%81%d1%82%d0%be%d0%b2%d1%8b%d0%b9%20%d0%bf%d0%b0%d1%80%d0%b0%d0%bc%d0%b5%d1%82%d1%80`

Опция `purl` отличается от `url` тем, что преобразует '/' в код
'%2F'

4. помещение сервиса sshd в автозапуск с проверкой и отметкой в
ini.env

   ` # Calculate path=/etc/runlevels/default name=sshd link=/etc/init.d/sshd symbolic ini(runlevels.openssh)!=on&&ini(runlevels.openssh,on)==`

**livemenu(mode)** - **(добавлена в версии 3.4)** - функция специального
назначения для формирования мультизагрузочного меню для Flash. *mode* -
режим работы функции, и может быть следующим:

-   submenu - возвращает список систем в следующем формате:

        идентификатор системы;
        полное название в загрузочном меню;
        путь до ядра;
        параметры для загрузки;
        путь до initrd;
        параметры загрузки splash;

        Пример:
        cl-2;
        Calculate Linux Desktop Xfce;
        /boot/vmlinuz-2;
        root=live:LABEL=CALCULATE;
        /boot/initrd-2;
        splash;

-   xorg - возвращает список систем, в которых установлен xorg-server.
    Например `cl-1 cl-2 cl-3`.
-   video - возвращает список систем, в которых присутствуют
    проприетарные драйверы. Например `cl-2 cl-3`

Функция используется в шаблонах
`6_ac_builder_iso/0_bootmenu/desktop.config`, а также для формирования
`gfxboot.cfg`.

**ls(dir,pattern)** - *(добавлена в 3.5) получить список из указанной
директории *dir*, и преобразовать согласно шаблону pattern. Если не
указывать *pattern* - список будет выведен через пробел.

-   dir - директория или шаблон пути к файлам (`/etc/conf.d` или
    `/etc/*.conf`)
-   pattern - шаблон преобразования списка файлов из директории.

Если pattern содержит `1` то вместо имени файла будет выведен текст
pattern, но вместо 1 будет имя файла.

Если же pattern не содержит `1`, то он используется как разделитель
между именами файлов.

`n` преобразуется в перевод строки. Если же нужно вывести `n`
используется `n`.

Пример.

    `#-ls(/etc/openldap/slapd.conf.d/*.conf,include 1n)-#`

При этом в @/etc/openldap/slapd.conf.d содержатся файлы unix.conf и
samba.conf

    `include /etc/openldap.slapd.conf.d/unix.conf`
    `include /etc/openldap.slapd.conf.d/samba.conf`

Пример 2

    files = #-ls(/etc/conf.d,,)-#

При этом в `/etc/conf.d` содержатся файлы net, modules, root

    `files = /etc/conf.d/net,/etc/conf.d/modules,/etc/conf.d/root`

**server(service.option,var)** - чтение значения параметра сервиса.
Информация получается путем обработки файла
`/var/calculate/remote/server.env`,

где:

-   *service* - название сервиса.
-   *option* - опция сервиса.
-   *var* - имя переменной функции(необязательный параметр).
    Разделитель *service* и *option*: '.' - точка.
    В случае использования *var* - имени переменной функции, полученное
    значение опции сервиса будет записана в переменную функции *var*.
    Если *var* не используется, полученное значение опции сервиса будет
    вставлено в текст конфигурационного файла.

Примеры:

1.  прочитаем значение порта для соединения с jabber-сервисом

        #-server(jabber,port)-#

получаем значение 5223

1.  прочитаем значение порта для соединения с jabber-сервисом и поместим
    в переменную функции `jabber_port`

        #-server(jabber,port,jabber_port)-#

Значение переменной функции jabber_port - 5223.

**list(var,index)** - вывод значения по индексу из переменной.
где:

-   *var* - название переменной функции или переменной шаблона (значение
    переменной должно быть списком).
-   *index* - индекс для поиска значения в переменной функции или
    переменной шаблона (первый элемент имеет индекс 0, и т.д.).

Пример.
Значение переменной
os_disk_dev = ['/dev/sda1', '/dev/sda2', '/dev/sda3',
'/dev/sda4', '/dev/sda5']

    #-list(os_disk_dev,1)-#

Метка функции будет заменена на '/dev/sda2'.

Если запрошен элемент, отсутствующий в списке, наложение шаблонов
прерывается с ошибкой. *Начиная с версии 2.2.17 - возвращает пустую
строку.*

**in(var,value1,value2...)** - проверяет есть ли среди значений
переменной var, хотя бы одно значение из value. Если значение найдено,
то возвращает "1", иначе пустую строку. Переменная может быть как
списком, так и строкой.

-   *var* - название переменной
-   *valueX* - список значений для сравнения

Пример:

Значение переменной строка
os_install_linux_shortname = CLDX

    #-in(os_install_linux_shortname,CLDX,CLD,CLDG)-#

Пример 2:

Значение переменной список
os_linux_pkglist = CLDX,base

    #-in(os_linux_pkglist,CLDX,CLD,CLDG)-#

Вернет 1, так как есть общее значение - CLDX.

Метка функции будет заменена на CLDX.

**kernel(kernel_opt)** - **(добавлена в версии 3.3.1)** получить
значение параметра конфигурации ядра. Возвращает "y","m" или пустую
строку. y - опция включена в ядро, m - модуль ядра, пустая строка -
опция выключена.

*kernel_opt* - регистронезависимое название опции без префикса CONFIG_

Пример 1. Включен ли ext4:

    kernel(ext4_fs)!=

Пример 1. reiserfs - модуль ядра, а ext4 - включен в ядро

    kernel(reiserfs_fs)==m&&kernel(ext4_fs)==y

**load(arg,path,opt)** - отображение информации из файла.
где:
*arg* - тип содержимого файла;
*path* - путь к файлу;
*opt* - необязательная опция

Возможные значения "opt":

-   *root* - путь к файлу не будет содержать chroot-пути. (Какой путь
    указан, такой и будет в действительности, вне зависимости от
    переменных `cl_chroot_path` и `cl_root_path`.)

Возможные значения "arg":

-   *ver* - содержимое файла номер версии
-   *num* - содержимое файла число
-   *char* - содержимое файла строка
-   *empty* - результат, содержимое файла без закомментированных
    (комментарии # или ;) и пустых строк.

Возможные значения "path":

-   *path* - абсолютный или относительный путь к файлу.

Пример. Выведем содержимое `/proc/cpuinfo` на место объявления функции:

    #-load(char,/proc/cpuinfo)-#

**module(module_name)** - **(добавлена в 3.5)** получить версию модуля
Calculate утилит. Если модуль отсутствует -возвращает пустое значение.
Если выполняются шаблоны для устанавливаемой системы, то функция вернёт
наименьшую версию модуля.

Пример. Запрос версии модуля client

    #-module(client)-#

Если в системе установлены утилиты (например версии 3.5.0_alpha1) с
модулем client, то вернёт `3.5.0_alpha1`.

**pkg (category/package)** - вывод версии установленного пакета, если в
системе установлено несколько версий этого пакета, ты выводится версия
максимального слота.
где:

-   *category* - категория пакета
-   *package* - название пакета
-   Начиная с версии утилит 3.1.0_beta2 добавилась возможность указывать
    слот пакета через двоеточие: `pkg(kde-base/kdelibs:4)`
-   Начиная с версии утилит 3.3 добавлена возможность проверять наличие
    USE флагов у пакета. Проверяемые USE флаги указываются в квадратных
    скобках, через запятую. Указание "-" перед USE флагом означает,
    что флаг у пакета должен быть выключен.

В качестве совместимого режима можно указывать только название пакета; в
этом случае скорость обработки шаблона будет ниже.

Пример. Выведем версию установленного пакета (например 4.2.4):

    #-pkg(kde-base/kdelibs)-#

Значит, в системе установлен пакет `kdelibs-4.2.4`.

Пример использования USE. Вывести версию установленного пакета, если он
собран с включенным `desktop` и выключенным `client` флагами.

    #-pkg(sys-apps/calculate-utils[desktop,-client])-#

**print (message)** - вывод на экран информационного сообщения во время
выполнения шаблона

**warning (message)** - вывод на экран предупреждающего сообщения во
время выполнения шаблона

**error (message)** - вывод на экран сообщения об ошибке во время
выполнения шаблона

**push(var, value)** - помещение значения переменной в стек переменных
функций шаблонов.

где:

-   *var* - имя переменной функции. Имя должно начинаться с буквы и
    может содержать латинские буквы и цифры. Переменная создается на
    время обработки конфигурационного файла.
-   *value* - значение переменной функции, значение присваивается
    переменной функции и заносится в стек переменных функций шаблонов.
    При отсутствии второго аргумента, в стек переменных функций шаблонов
    будет записано значение переменной.

Примеры:

1.  Создадим переменную "test" и присвоим ей значение 15, запишем в
    стек переменных функций шаблонов.

        #-push(test,15)-#

1.  Запишем в стек переменных функций шаблонов значение ранее созданной
    переменной `test`:

        #-push(test)-#

**pop(var)** - извлечение значения из стека переменных функций шаблонов
и присвоение его переменной.

-   *var* - имя переменной функции. Имя должно начинаться с буквы и
    может содержать латинские буквы и цифры. Переменная создается на
    время обработки конфигурационного файла.

Примеры:

1.  Создадим переменную "test" и присвоим ей значение 15, запишем в
    стек переменных функций шаблонов.

        #-push(test,15)-#

1.  Получим значение из стека переменных функций шаблонов и присвоим его
    переменной `test2`:

        #-pop(test2)-#

Получить значение из стека переменных функций шаблонов возможно как в
текущем шаблоне, так и в любом другом.
После получения значения оно удаляется из стека.

**replace(old, new, var)** - замена в значении переменной `var` текста
*old* на *new*.
где:

-   *old* - текст, каждое вхождение которого в значении переменной будет
    заменено на текст *new*
-   *new* - текст, на который в значении переменной будет заменен текст
    *old*
-   *var* - название переменной функции или переменной шаблона

Текст *old* и *new* должен быть заключен в двойные или одинарные
кавычки.

В тексте в двойных кавычках обрабатываются управляющие символы (',
", n, r, t, ).
Начиная с версии 3.2.3-r3 в двойных кавычках также обрабатывается xFF,
где FF двузначный шестнадцатеричный код символа.
В одинарных кавычках текст не обрабатывается.

Пример.
значение переменной шаблона *ur_signature*

    Компания «Калкулэйт»nРоссия, Санкт-Петербург, пл. Стачек, 4nhttp://www.calculate.run+7 812 3363632n+7 495 7727678

при выполнении функции

    #-replace('n',"n",ur_signature)-#

в точку вставки будет вставлен следующий текст (символ "n" будет
заменен на перевод строки)

    Компания «Калкулэйт»
    Россия, Санкт-Петербург, пл. Стачек, 4
    http://www.calculate.ru
    +7 812 3363632
    +7 495 7727678

Ниже приведенный пример позволяет преобразовать пробел в значении
`hr_board_model` в символ подчеркивания.

    ...
    |main.hr_board_model | rs  |            |P8H77-V LE|
    ...

    #?replace("x20","_",main.hr_board_model)==P8H77-V_LE#
    ...
    #replace#

**rnd(type,len)** - вывод случайной комбинации символов.
где:

-   *type* - используемые символы, возможные значения: num - числа,
    pas - числа и буквы, uuid - числа и буквы от a-f. (uuid добавлен
    начиная с версии 2.2.17). Начиная с версии 3.5 uuid переименовано в
    hex, а генерация uuid происходит согласно формату UUID.
-   *len* - количество символов (число). Можно не указывать при
    генерации uuid в утилитах 3.5.

Пример. Выведем три 3 случайных числа (например 372):

    #-rnd(num,3)-#

Пример для 3.5. Сгенерируем половину UUID и полный UUID.

    #-rnd(uuid,16)-#
    #-rnd(uuid)-#

**sum(var,sum_print, sum_out)** - вычисляемые значения смещений. Функция
разрабатывалась для настройки Plasma

где:

-   *var* - имя переменной функции "sum". Имя должно начинаться с
    буквы и может содержать латинские буквы и цифры. Переменная
    создается на время обработки конфигурационного файла.
-   *sum_print* - арифметическое выражение, результат которого будет
    отображен на месте объявления функции. При отсутствии аргумента
    значение выводиться не будет. Поддерживаются операции сложения "+"
    и вычитания "-", деления "/" и умножения "*". В
    арифметическом выражении могут участвовать другие переменные
    функции, а также переменные шаблона.
-   *sum_out* - арифметическое выражение, результат которого будет
    присвоен переменной "var" (первому аргументу функции). При
    отсутствии третьего аргумента переменной "var" будет присвоено
    вычисленное значение второго аргумента.

Примеры:

1.  Создадим переменную "clock" и присвоим ей значение 15, не выводя
    результат.

        #-sum(clock,,15)-#

1.  Создадим переменную "bt", присвоим ей значение переменной
    "clock" и выведем значение.

        #-sum(bt,clock)-#

1.  Разместим кнопку на панели шириной "35" пикселов, оставив отступ в
    "4" пиксела по краям:

        #-sum(bt,bt+2,bt+35+2)-#

**wallpaper(resolution, wallpapers_path, file)** - функция выбирает
наиболее подходящее по указанному разрешению изображение из папки. До
версии 3.5 функция возвращала только имя файла, начиная с 3.5 - полный
путь. Для получения имени файла используется третий параметр.

где:

-   *resolution* - требуемое разрешение (текущее разрешение можно
    получить из переменных `os_x11_resolution`,
    `os_install_x11_resolution`)
-   *wallpapers_path* - путь, где находится изображение в разных
    разрешениях. Формат файлов: `разрешение.расширение`. Например:
    1024x768.jpg
-   *file* - (*добавлено в 3.5) может принимать только 'file' как
    значение, при этом функция вернёт только имя файла.

Начиная с версии 3.5.2 `wallpapers_path` может быть указан файлом. В
этом случае функция вернёт указанное изображение.

Пример для версии 3.5:

Папка `/usr/share/wallpapers/1` содержит следующие изображения:

-   1024x768.jpg
-   1280x1024.jpg
-   1680x1050.jpg
-   1920x1080.jpg

    #-wallpaper(1280x720,/usr/share/wallpapers/1)-#

вернет `/usr/share/wallpapers/1/1920x1080.jpg` как наиболее подходящую
по пропорциям

    #-wallpaper(1280x720,/usr/share/wallpapers/1,file)-#

вернет `1920x1080.jpg`

Для получения текущего разрешения можно использовать выше указанные
переменные

    #-wallpaper(#-install.os_install_x11_resolution-#,/usr/share/wallpapers/1)-#

**profile()** - **добавлена в 3.5.2**, функция используется при
настройке пользовательского профиля и возвращает её состояние.

-   **configured** профиль настроен утилитами
-   **empty** профиль пустой, или содержит только файлы /etc/skel
-   **custom** профиль настроен не утилитами Calculate

Значения `empty` и `custom` используются только для первого определения
состояния пользовательского профиля: в первом случае профиль будет
настроен утилитами, во втором случае получит пометку в
.calculate/ini.env о том, что профиль не нужно настраивать в дальнейшем.
Профиль же содержащий `.calculate/ini.env` всегда `configured`.

**world(category)** - **добавлена в 3.5.6**, функция используется для
формирования `world` файла. Возвращает список пакетов указанной
категории, доступных для установке. Если категория не содержит пакетов
для установки или указана неверно, будет выведено предупреждающее
сообщение.

Пример:

    #-world(dev-lang)-#

    ...
    dev-lang/orc:0
    dev-lang/perl:0
    dev-lang/php:7.0
    ...

### Способы объединения

Существуют несколько способов объединения шаблона установки с исходным
файлом системы:

-   **join** - основной способ объединения - методом слияния двух
    файлов. Подробно описан в "схеме объединения".
-   **before** - шаблон переписывается в начало оригинального файла
-   **after** - шаблон переписывается в конец оригинального файла
-   **replace** - шаблон переписывается заменяя оригинальный файл
-   **delete** - объединение не происходит, оригинальный файл удаляется
-   **remove** - вместо объединения происходит удаление оригинального
    файла

Изменение шаблона перед объединением, для способов объединения
"before", "after", "replace":

-   если существуют *управляющие элементы*, то они обрабатываются
-   если существует *заголовок*, то он обрабатывается
-   если существует параметр *format* в *заголовке* то происходит
    обработка *управляющих символов*: "+, -, !"

#### Правила по умолчанию

По умолчанию способ объединения устанавливается в соответствии с
форматом файла.
Для форматов файлов основных приложений "samba", "bind" и т.п. по
умолчанию действует объединение "join", для формата "raw" и
"bin" - объединение "replace". Для пустого файла по умолчанию
действует правило объединения "delete" - конечный файл удаляется из
системы.

Правила объединения могут быть изменены установкой параметра "append"
заголовка файла шаблона.

## Расположение

### Правила именования файлов

Имена файлов шаблона могут содержать условные операторы, определяющие
правила, при выполнении которых файл шаблона будет перенесен в систему.
Подобно ссылке на страницу сайта условия отделяются от имени знаком
вопроса (?), после которого могут идти условные операторы, подробно
описанные в условных блоках (см. выше).

Арифметические операции могут объединяться условием И (&) и ИЛИ (?).
Приоритет в данном случае будет отдаваться условию И.

Пример:

    grub.conf?os_linux_shortname==CDS?os_linux_shortname==CLD

В приведенном примере файл шаблона выполнит настройки загрузчика как для
систем Calculate Linux Desktop, так и для Calculate Directory Server

При наличии условных операторов в заголовке файла шаблона для переноса
файла шаблона в систему должны выполняться оба условных выражения.

### Правила именования директорий

Правила именования директорий схожи с правилами именования файлов. При
выполнении условий, заданных условными операторами, директория будет
перенесена в систему; в противном случае директория вместе с содержимым
будет пропущена.

### Права доступа

Права доступа конфигурационного файла после объединения с файлом шаблона
устанавливаются по следующим приоритетам:

-   при наличии конфигурационного файла в системе права будут сохранены
    неизменными;
-   в случае отсутствия оригинального конфигурационного файла, права
    будут выставлены как 644 для файла и 755 для директории;
-   в случае установки значения переменной "chmod" или "chown"
    заголовка файла шаблона, права на конфигурационный файл будут
    изменены согласно установленному значению.

### Символические ссылки

Для создания символических ссылок используйте параметры "link +
symbolic" заголовка файла шаблона.

Если помимо заголовка файл шаблона будет содержать тело шаблона,
оригинальный файл будет модифицирован согласно правилам объединения.

Calculate не будет переносить так называемые "битые ссылки" - ссылки,
не ведущие ни на какой файл (директорию), если явно не указан параметр
`force`.

## Схема объединения

Объединение - изменение настроек оригинального файла настроек в
соответствии с настройками *файла шаблона*.

В процессе объединения все записи оригинального файла и файла шаблона
разбиваются на *элементы*: *области, переменные, списки, разделённые
списки, комментарии, управляющие элементы* (см. ниже).

Файл шаблона должен быть составлен с применением синтаксиса
оригинального файла. Расположение элементов оригинального файла при
объединении сохраняется. Во время объединения комментарии из файла
шаблона не переносятся.

### Правила объединения

Над элементами могут происходит операции *Объединение, Замена,
Удаление*:

#### Объединение

-   Отсутствующие в оригинальном файле элементы дописываются в конец
    области. При этом в случае наличия перевода строки перед вставляемым
    элементом перевод строки добавляется после вставляемого элемента. В
    противном случае перевод строки добавляется перед вставляемым
    элементом.
-   В случае объединения разделённого списка, отсутствующие элементы
    добавляются следом за последним элементом разделённого списка
    конфигурационного файла.

#### Замена

-   Значение элементов заменяется на новое. При этом форматирование
    переносится из файла шаблона.

#### Удаление

-   Элемент удаляется вместе с переводом строки, стоящим перед
    элементом.

### Правила объединения, действующие по умолчанию

Правила объединения действуют на **элементы с одним именем**,
расположенные в **одной области шаблона**.

**При нахождении различий, по умолчанию действуют следующие правила:**

-   **Области** - содержимое двух областей *объединяется (+)*.
-   **Переменные** - значения переменных *заменяются (-)*.
-   **Списки** - содержимое списков *заменяется (-)*.
-   **Разделённые списки** - аналогично правилу объединения переменных -
    значения списков *заменяются (-)*.

### Изменение правил объединения

Для изменения правил объединения действующих по умолчанию, в начале
**имени элемента** в файле шаблона добавляется управляющие символы:

-   **"+"** - объединить элементы (для областей и списков); после
    объединения остаются только уникальные элементы
-   **"-"** - значение элемента заменяется
-   **"!"** - элемент удаляется
    В CXmlConf описания файла шаблона эти правила описываются тэгом
    "\<action\>".

## Формат CXmlConf

CXmlConf - универсальный формат описания конфигурационных файлов. Служит
для **выборочного изменения настроек** большинства распространенных
типов конфигурационных файлов ОС Linux/Unix.

XML файл описания настроек разбивает конфигурационный файл на логические
структуры - **элементы**, пригодные для последующего объединения. После
объединения файл может быть преобразован в первозданный вид за
некоторыми исключениями (см. Схема объединения).

Описания элементов вкладываются в конструкцию:
```
    <cxmlconf>
      <head>
        <ver>версия формата</ver>
        <format>формат конфигурационного файла</format>
      </head>
      <body>
        [<area>...</area>... <field>..</field>]
      </body>
    </cxmlconf>
```
Где:

-   *ver* - передает номер версии разметки
-   *format* - формат конфигурационного файла (определяется по
    распространенным программам).

Все элементы (см. ниже) помещаются внутрь элемента \<body/\>.

### Области

Области конфигурационных файлов разграничивают **пространство имен
переменных**. Области могут содержать логические структуры, в том числе
другие области (пример: Filename|named.conf).

Области помещается в конструкцию:
```
    <area>
      <caption>
        <name>Заголовок области</name>
        <action>join|replace|drop</action>
        <quote>Начальная часть области (заголовок)</quote>
        <quote>Завершающая часть описания области</quote>
      </caption>

      [<field></field>...]

    </area>
```
### Переменные

Переменные имеют запись в виде:
```
    <field type="var">
      <name>имя переменной</name>
      <value>значение переменной</value>
      <action>join|replace|drop</action>
      <quote>Оригинальный текст описания</quote>
    </field>
```
В некоторых конфигурационных файлах, например,
`/etc/openldap/slapd.conf`, встречается конструкция:

    index   cn              pres,sub,eq
    index   sn              pres,sub,eq
    index   uid             pres,sub,eq

В этом случае имя переменной состоит из первой и второй части, а
значение - из третьей.

Cтрока

    index   cn              pres,sub,eq

В XML это будет выглядеть так:

```
    <field type="var">
      <name>indexcn</name>
      <value>pres,sub,eq</value>
      <quote>index   cn              pres,sub,eq</quote>
    </field>
    <field type="br" >
```
### Списки

По примеру файла `named.conf`, блок "listen-on" может содержать одни
значения - значения блока, а не переменных.

Для обозначения значений служит конструкция:

```
    <field type="list">
      <name>hostsallow</name>
      <value>192.168.0.0/24</value>
      <value>127.</value>
      <action>join|replace|drop</action>
      <quote>Оригинальный текст списка</quote>
    </field>
```
где внутри блока "\<quote\>" сохраняется оригинальный текст описания
значения, без завершающего перевода строки.

### Разделённые списки

Файл настроек веб-сервера *Apache* может содержать инструкцию
"Include", позволяющую делать исходный файл модульным. Подобные случаи
описываются в "CXmlConf", как "Разделённые списки".

Разделенные списки описываются следующей конструкцией:
```
    <field type="seplist">
      <name>Include</name>
      <value>/etc/apache2/modules.d/*.conf</value>
      <action>join|replace|drop</action>
      <quote>Оригинальный текст списка</quote>
    </field>
```
### Комментарии

При объединении конфигурационных файлов комментарии оригинального файла
сохраняются в неизменном виде.

Все типы комментариев помещаются в конструкцию "\<comment\>". В
тексте, помещаемом в "\<quote/\>", сохраняются символы комментария и
перевод строки:
```
    <field type="comment">
      <quote>Оригинальный текст комментария</quote>
    </field>
```
Комментарии не могут быть вложенными (быть описаны в других конструкциях
комментариев).

### Управляющие элементы

Для обозначения **перевода строк** служит конструкция:
```
    <field type="br">
      <quote>разделительные элементы (пробелы, табуляция)</quote>
    </field>
```
Где:

-   "quote" содержит элементы форматирования (пробелы, табуляция)

## Формат XML

### Поддерживаемые форматы XML

В настоящее время реализована поддержка форматов xml_xfce (XML файл для
конфигурирования оконного менеджера XFCE), xml_xfcepanel (XML файл для
конфигурирования панелей оконного менеджера XFCE), xml_gconf (XML файл
для конфигурирования GNOME)

### Отличия от формата CXmlConf

-   XML файлы хранятся и обрабатываются без перевода их в другой формат.
-   Все правила, функции, переменные действуют на файл XML-шаблона
    аналогично обычному шаблону за исключением операций объединения
    элементов XML

### Объединение элементов XML

Для объединения элементов XML в тексте XML шаблона используется атрибут
XML-элемента - 'action'

Допустимые значения атрибута

-   action="join" - элементы объединяются (действует по умолчанию)
-   action="replace" - элемент шаблона замещает элемент файла
-   action="drop" - элемент файла удаляется

#### Формат xml_xfce

Формат состоит из элементов "channel" и "property".

В атрибутах "channel" находится имя и версия файла.

Внутри элемента "channel" находятся элементы "property".

Пример элемента "channel":
```
    <channel name="xfwm4" version="1.0">
      <property name="general" type="empty">
      .....
      </property>
    </channel>
```
Пример элемента "property":

    <property name="wrap_workspaces" type="bool" value="false"/>

У каждого элемента "property" есть атрибут type.

Если type="array", то этот элемент и внутренние элементы будут
заменены на элементы из шаблона.
Иначе элементы будут объединены.

Пример type="array":
```
    <property name="workspace_names" type="array">
      <value type="string" value="Рабочее место 1"/>
      <value type="string" value="Рабочее место 2"/>
      <value type="string" value="Рабочее место 3"/>
      <value type="string" value="Рабочее место 4"/>
    </property>
```
#### Формат xml_xfcepanel

Формат состоит из следующих элементов: "panels", "panel",
"properties", "property", "items", "item".

Если элемент "items", то этот элемент и внутренние элементы будут
заменены на элементы из шаблона.
Иначе элементы будут объединены.

Пример элемента "items":
```
    <items>
      <item name="xfce4-mixer-plugin" id="9"/>
      <item name="clock" id="10"/>
      <item name="separator" id="52"/>
      <item name="actions" id="12"/>
    </items>
```
#### Формат xml_gconf

Формат состоит из элементов "entry".
Если у элемента "entry" есть атрибут "ltype" (список) или атрибут
*type="string"* то этот элемент и внутренние элементы будут заменены
на элементы из шаблона, в ином случае элементы будут объединены.

Атрибут элемента "entry" - "mtime" при изменении элемента "entry"
показывает время, когда произошло изменение в секундах.

Пример шаблона xml_gconf:
```
    # Calculate format=xml_gconf
    <?xml version="1.0"?>
    <gconf>
            <entry name="rgba_order" mtime="1235158855" type="string">
                  <stringvalue>rgb</stringvalue>
           </entry>
           <entry name="dpi" mtime="1235162438" type="float" value="86">
           </entry>
           <entry name="hinting" mtime="1235266915" type="string">
                   <stringvalue>full</stringvalue>
           </entry>
           <entry name="antialiasing" mtime="1235266915" type="string">
                   <stringvalue>rgba</stringvalue>
           </entry>
    </gconf>
```
#### Формат xml_gconf_tree

Формат состоит из элементов "dir" и "entry" и их атрибутов.

Атрибуты элементов будут объединены в случае 'join'-объединения.

При объединении шаблона и конфигурационного файла элементы "entry"
конфигурационного файла будут заменены, соответствующими элементами
"entry" шаблона.

Атрибут элемента "entry" - "mtime" при изменении элемента "entry"
показывает время когда произошло изменение в секундах.

Пример шаблона xml_gconf:
```
    # Calculate format=xml_gconf_tree
    <?xml version="1.0"?>
    <gconf>
        <dir name="desktop">
            <dir name="gnome">
                <dir name="volume_manager">
                    <entry name="percent_used" mtime="1285580987" schema="/schemas/desktop/gnome/volume_manager/percent_used"/>
                            </dir>
                    </dir>
            </dir>
    <gconf>
```

### Примеры использования

Файл шаблона:
```
    # Calculate format=xml_xfce
    <?xml version="1.0" encoding="UTF-8"?>
    <channel name="xfce4-session" version="1.0">
      <property name="general" type="empty" action="drop">
        <property name="FailsafeSessionName" type="empty"/>
        <property name="SessionName" type="string" value="Default"/>
        <property name="SaveOnExit" type="bool" value="true"/>
      </property>   
    </channel>
```
Cтрока *\<property name="general" type="empty" action="drop"\>*
говорит о том, что этот элемент и все элементы внутри будут удалены.

Получившийся в результате файл имеет следующий вид:
```
    <?xml version="1.0" encoding="UTF-8"?>
    <channel name="xfce4-session" version="1.0">
    </channel>
```
## Формат 'patch'

Формат *patch* используется для обработки конфигурационных файлов при
помощи регулярных выражений языка программирования Python.

### Особенности.

Формат *patch* использует обработку конфигурационного файла на основании
шаблона (тип объединения *patch*); при этом не происходит объединения
шаблона и конфигурационного файла.

Обработка исходного файла происходит целиком, а не построчно, поэтому
символы '`^`' и '`$`' означают соответственно начало и конец файла.
Символ '`.`' означает любой символ исключая перевод строки.

Начиная с версии `calculate-lib-3.1.7-r5` в параметры заголовка для
`format=patch` добавлены опции **multiline** и **dotall**. При
включенном **multiline** '`^`' и '`$`' обозначают начало и конец
строки. При включенном **dotall** '`.`' включает в себя перевод
строки.

### Описание.

Шаблон формата *patch*:
```
    # Calculate format=patch
    <reg>регулярное выражение python 1</reg>
    <text>текст 1 для замены регулярного выражения</text>
    <reg>регулярное выражение python 2</reg>
    <text>текст 2 для замены регулярного выражения</text>
    ...
```
В содержимом тегов `reg` и `text` символы "&", "\<", "\>" должны
быть заменены на "&amp;", "&lt;", "&gt;" соответственно.

Пример:
```
    # Calculate format=patch
    <reg>TEXT&amp;DATA</reg>
    <text>TEXT_CONFIG</text>
```
Этот шаблон заменит в конфигурационном файле *TEXT&DATA* на
*TEXT_CONFIG*.

## Формат 'diff'

Добавлен начиная с версии 3.1.4

Формат *diff* используется для наложение diff патчей на исходный код
пакета. Сам файл в системе не создается, а полученное содержимое
обрабатывается относительно каталога указанного в параметре `path`.

Пример:
```
    # Calculate format=diff
    --- panel-plugin/xkb-cairo.c    2012-07-17 16:23:24.997030066 +0400
    +++ panel-plugin/xkb-cairo.c    2012-07-17 16:47:34.107054590 +0400
    @@ -27,7 +27,7 @@
     #include "xkb-util.h" 
     #include "xfce4-xkb-plugin.h" 

    -#define XKB_PREFERRED_FONT "Courier New, Courier 10 Pitch, Monospace Bold %d" 
    +#define XKB_PREFERRED_FONT "Droid Sans, Courier New, Courier 10 Pitch, Monospace Bold %d" 
```
## Формат 'kernel'

Добавлен начиная с версии 3.3.0.16

Формат *kernel* используется для объединения конфигурационных файлов
ядра без сохранения комментариев.

Пример:
```        
    # Calculate format=kernel
    CONFIG_XFS_FS=m
    CONFIG_REISERFS_FS=y
    # CONFIG_EXT3_FS is not set
    !CONFIG_EXT3_FS_POSIX_ACL=
    !CONFIG_EXT3_FS_SECURITY=
    !CONFIG_EXT3_FS_XATTR=
```
## Формат 'dconf'

Добавлен, начиная с версии 3.3.2.9

Формат *dconf* используется для модификации настроек пользователя,
хранящихся в реестре dconf. Формат *dconf* поддерживает параметр
заголовка *dconfpath* для возможности изменять базовый путь настроек.

Пример:
```
    # Calculate format=dconf dconf=/org/gnome/eog/
    [view]
    background-color='#000000'
    use-background-color=true

    [ui]
    statusbar=true
    toolbar=true
    sidebar=false
```
Для применения шаблонов формата *dconf*, утилиты используют пакет
`gnome-base/dconf`.

## Формат 'json'

Добавлен, начиная с версии 3.4.1

Формат *json* используется для модификации настроек в формате json
(например `Perferences` пакета `www-client/chromium`).

Пример *json*
```json
    {"google": {"services": {"signin": {"LSID": "", "SID": ""}}},
     "intl": {"accept_languages": "ru-RU,ru,en-US,en", "status": 1}}
```
При объединении элементов в конфигурационном файле меняются только
конкретные значения.

Для изменения правил объединения действующих по умолчанию, в начале
**имени элемента** в файле шаблона добавляется управляющие символы:

-   **"-"** - ветка заменяется
-   **"!"** - ветка удаляется

Пример объединения
```json
    # Calculate format=json
    {"intl":{"accept_languages": "en"}}

    {"google": {"services": {"signin": {"LSID": "", "SID": ""}}},
     "intl": {"accept_languages": "en", "status": 1}}
```
Пример удаления
```json
    # Calculate format=json
    {"!intl":""}

    {"google": {"services": {"signin": {"LSID": "", "SID": ""}}}}
```
Пример замещения
```
    # Calculate format=json
    {"-intl":{"accept_languages": "en"}}

    {"google": {"services": {"signin": {"LSID": "", "SID": ""}}},
     "intl": {"accept_languages": "en"}}
```
Ветка настроек также будет замещена если в шаблоне содержится значение.

Пример замещения
```
    # Calculate format=json
    {"intl": 5}

    {"google": {"services": {"signin": {"LSID": "", "SID": ""}}},
     "intl": 5}
```
## Формат 'contents'

Добавлен, начиная с версии 3.5

Формат *contents* используется для модификации принадлежности файлов
пакетам. Позволяет добавлять файлы пакету, удалять, а так же менять
пакет, которому принадлежит файл. Каждая строка шаблона является
инструкцией, описывающей действие с файлами. Игнорируются пустые строки,
а также строки-комментарии начинающиеся с `#`.

#### Добавление файла пакету.

    \<package\> \<path\>

-   **package** - пакет к которому будет добавлен файл. Пакет может быть
    указан с версией или со слотом, для уточнения.
-   **path** - путь в файловой системе. Поддерживаются глобальные
    символы (*, [], [!], ?)

Добавление файла пакету происходит, даже если файл уже принадлежит
другому пакету. Если в системе два пакета, а в правиле не указан слот,
то файл будет добавлен пакету, у которого версия больше. Контрольная
сумма по файла вычисляется при добавлении.

#### Удаление принадлежности файла пакету.
```
    !<package> <path>
```
При получении списка удаляемых файлов (использование глобальных
символов) используется список файлов пакета, а не файловая система. Если
в системе два пакета, а в правиле не указан слот, то файл будет удалён
из обоих пакетов.

#### Перенос файла от одного пакета другому

   \<source\>,\<target\> \<path\>

-   **source** - пакет из которому будет удалён файл
-   **target** - пакет к которому будет добавлен файл
-   **path** - путь в файловой системе. Поддерживаются глобальные
    символы (*, [], [!], ?)

При получении списка файлов, так же как и при удалении, используется
список файлов пакета `source`, а не файловая система. Контрольная сумма
файлов будет перенесена из пакета source. Таким образом, если файл
редактировался пользователем, пока принадлежал пакету source, то после
привязки его пакету target будет видим системой, как изменённый.

#### Примеры
```
    # Calculate format=contents

    # добавить пакету openrc файлы из /etc/conf.d начинающиеся на dhcp
    sys-apps/openrc /etc/conf.d/dhcp*

    # добавить в пакет udisks, второй слот
    sys-fs/udisks:2 /etc/polkit-1/rules.d/60-*

    # добавить в пакет udisks с версией 1.0.5-r1
    sys-fs/udisks-1.0.5-r1 /etc/polkit-1/rules.d/60-*

    # убрать принадлежность /etc/conf.d/hostname пакету openrc
    !sys-apps/openrc /etc/conf.d/hostname

    # перенести файлы принадлежащие sys-apps/baselayout из /etc/conf.d в пакет openrc
    sys-apps/baselayout,sys-apps/openrc /etc/conf.d/*
```
## Формат 'backgrounds'

Добавлен, начиная с версии 3.5.2. Для работы необходим пакет
`media-gfx/imagemagick`.

Формат *backgrounds* используется для создания множества фоновых
изображений разных разрешений из исходного.

Используются следующие параметры заголовка:

-   **link=** параметр, указывающий на исходное изображение, если
    параметр не указан или указан на несуществующий файл, то изображения
    не будут создаваться
-   **convert=** формат и расширение конечных фоновых изображений
    (`jpg`, `png`, `gif`, `gfxboot`), по умолчанию формат исходного
    изображения тот же, что и расширение исходного файла.
-   **stretch** создавать изображения, даже если исходное изображение
    меньше необходимого
-   **mirror** если исходное изображение отсутствует, то будут удалены
    все ранее созданные этим шаблоном изображения
-   **path=** каталог, в который будут помещены созданные изображения
-   **name=** префикс добавляемый к имени файла

Имена изображений формируются следующим образом:
`(prefix)(resolution).(format), где @prefix` - имя получаемое из
параметра `name=`, `resolution` - разрешение, создаваемого изображения,
`format` - формат изображения (jpg, png, gif или gfxboot). Gfxboot -
jpeg с определёнными параметрами, которые подходят для установки
изображения в качестве фонового изображение syslinux-gfxboot.

Содержимое формата - набор строк, содержащих разрешения создаваемых
изображений. Если содержимое не указано, то будет использован список
стандартных разрешений, указанных в переменной `main.cl_resolutions`.

Если разрешение исходного изображения меньше конечного, то изображение
не будет создано, и будет выведено предупреждение. Если же указан
параметр **stretch** - исходное изображение будет растянуто, до
необходимого.

Для предотвращения повторного выполнения шаблона, используется файл с
контрольной суммой исходного изображения.

Все созданные изображения (а так же файл контрольной суммы)
"привязываются" к настраиваемому шаблонами пакету.

Если указано только одно разрешение, то будет создан только один файл с
требуемым разрешением, причём имя конечного файла будет состоять из
`path/name`. Файл с контрольно суммой создан не будет.

Начиная с версии утилит `3.6.4` добавлена возможность указать вместо
разрешения `original`, что означает разрешение исходного изображения.
Может быть использовано, например, для конвертации изображения из одного
формата в другой.

### Примеры.

Создать изображения в
`/usr/share/wallpapers/Calculate_Linux/images/contents/images`, с
именами вида 1920x1080.jpg из /usr/share/backgrounds/bg.png, не создавая
изображения с разрешением больше, чем у исходного.
```
    # Calculate format=backgrounds convert=jpg link=/usr/share/backgrounds/bg.png 
    path=/usr/share/wallpapers/Calculate_Linux/images/contents/images name=
```
Создать изображения в `/etc/splash/calculate/images`, с именами вида
silent-1920x1080.jpg из /usr/share/backgrounds/bg.png, при необходимости
исходное изображение будет растянуто.
```
    # Calculate format=backgrounds convert=jpg stretch 
    link=/usr/share/backgrounds/bg.png path=/etc/splash/calculate/images name=silent-
```
Создать одно изображение /boot/grub/grub-calculate.png с разрешением
1920x1440.
```
    # Calculate format=backgrounds path=/boot/grub name=grub-calculate.png 
     link=/usr/share/backgrounds/bg.png stretch
    1920x1440
```
## Формат 'world'

Формат для модификации файла world. Содержит список пакетов, которые
необходимо либо добавить в файл, либо удалить из него. Для удаления
пакета из world используется синтаксис `!\<пакет\>`. Для удаления с
проверкой (в случае отсутствия необходимо пакета будет выведено
предупреждающее сообщение) - `!!\<пакет\>`.Если файл со списком назван так
же как категория, то внутри можно не указывать категорию для пакетов.

Начиная с версии `3.6.1.2` для удаления пакета во всех слотах
используется синтаксис `!\<пакет\>:*`.

### Примеры.

Добавлить `sys-apps/calculate-utils` в world
```
    # Calculate format=world path=/var/lib/portage/world
    sys-apps/calculate-utils
```
Удалить все `dev-db/postgresql` из world с проверкой
```
    # Calculate format=world path=/var/lib/portage/world
    !!dev-db/postgresql:*
```
Добавить в calculate-utils, portage, sed из категории sys-apps

sys-apps
```
    # Calculate format=world path=/var/lib/portage/world
    calcualte-utils
    portage
    sed
```

